"""
3D Export Module - Export pose data to 3D formats
Supports Blender, FBX, BVH, and other 3D animation formats
"""

import numpy as np
import pandas as pd
import json
from typing import Dict, List, Optional, Tuple, Any
from pathlib import Path
from dataclasses import dataclass
import struct


@dataclass
class Bone:
    """Represents a bone in the skeleton hierarchy."""
    name: str
    parent: Optional[str]
    position: Tuple[float, float, float]
    rotation: Tuple[float, float, float]
    children: List[str]


class Export3D:
    """
    Export pose data to various 3D formats for animation software.
    """

    # MediaPipe to skeleton bone mapping
    SKELETON_HIERARCHY = {
        'root': {'parent': None, 'landmark': 0},  # Nose as root
        'spine': {'parent': 'root', 'landmarks': [11, 12, 23, 24]},  # Torso
        'neck': {'parent': 'spine', 'landmarks': [11, 12]},
        'head': {'parent': 'neck', 'landmark': 0},

        # Left arm
        'left_shoulder': {'parent': 'spine', 'landmark': 11},
        'left_upper_arm': {'parent': 'left_shoulder', 'landmark': 13},
        'left_forearm': {'parent': 'left_upper_arm', 'landmark': 15},
        'left_hand': {'parent': 'left_forearm', 'landmarks': [15, 17, 19, 21]},

        # Right arm
        'right_shoulder': {'parent': 'spine', 'landmark': 12},
        'right_upper_arm': {'parent': 'right_shoulder', 'landmark': 14},
        'right_forearm': {'parent': 'right_upper_arm', 'landmark': 16},
        'right_hand': {'parent': 'right_forearm', 'landmarks': [16, 18, 20, 22]},

        # Left leg
        'left_hip': {'parent': 'root', 'landmark': 23},
        'left_thigh': {'parent': 'left_hip', 'landmark': 25},
        'left_shin': {'parent': 'left_thigh', 'landmark': 27},
        'left_foot': {'parent': 'left_shin', 'landmarks': [27, 29, 31]},

        # Right leg
        'right_hip': {'parent': 'root', 'landmark': 24},
        'right_thigh': {'parent': 'right_hip', 'landmark': 26},
        'right_shin': {'parent': 'right_thigh', 'landmark': 28},
        'right_foot': {'parent': 'right_shin', 'landmarks': [28, 30, 32]}
    }

    def __init__(self, fps: float = 30.0):
        """
        Initialize the 3D export system.

        Args:
            fps: Frames per second for animation
        """
        self.fps = fps
        self.skeleton = self._build_skeleton()

    def export_to_blender_python(self,
                                pose_data: pd.DataFrame,
                                output_path: str,
                                armature_name: str = 'PoseArmature') -> str:
        """
        Export pose data as a Blender Python script.

        Args:
            pose_data: DataFrame with pose landmarks
            output_path: Path for output .py file
            armature_name: Name for the armature in Blender

        Returns:
            Path to generated script
        """
        script_lines = [
            "# Blender Python Script - Generated by BodyScript",
            "# Run this script in Blender to create animated armature",
            "",
            "import bpy",
            "import mathutils",
            "from mathutils import Vector, Quaternion",
            "",
            "# Clear existing mesh objects",
            "bpy.ops.object.select_all(action='SELECT')",
            "bpy.ops.object.delete(use_global=False)",
            "",
            f"# Create armature",
            "bpy.ops.object.armature_add()",
            f"armature = bpy.context.object",
            f"armature.name = '{armature_name}'",
            "bpy.ops.object.mode_set(mode='EDIT')",
            "",
            "# Create bones",
            "edit_bones = armature.data.edit_bones",
            ""
        ]

        # Add bone creation
        bone_positions = self._calculate_bone_positions(pose_data)

        for bone_name, bone_info in self.SKELETON_HIERARCHY.items():
            if bone_name == 'root':
                continue

            parent = bone_info['parent']
            if 'landmark' in bone_info:
                landmark = bone_info['landmark']
            elif 'landmarks' in bone_info:
                landmark = bone_info['landmarks'][0]
            else:
                continue

            script_lines.extend([
                f"# Create {bone_name}",
                f"bone = edit_bones.new('{bone_name}')",
                f"bone.head = (0, 0, {landmark * 0.1})",
                f"bone.tail = (0, 0.1, {landmark * 0.1})",
            ])

            if parent and parent != 'root':
                script_lines.append(f"bone.parent = edit_bones['{parent}']")

            script_lines.append("")

        # Switch to pose mode for animation
        script_lines.extend([
            "# Switch to pose mode",
            "bpy.ops.object.mode_set(mode='POSE')",
            "pose_bones = armature.pose.bones",
            "",
            "# Set animation length",
            f"bpy.context.scene.frame_end = {pose_data['frame_id'].max()}",
            ""
        ])

        # Add keyframes for each frame
        script_lines.append("# Add animation keyframes")

        for frame_id in pose_data['frame_id'].unique():
            frame_data = pose_data[pose_data['frame_id'] == frame_id]

            script_lines.extend([
                f"# Frame {frame_id}",
                f"bpy.context.scene.frame_set({frame_id})",
                ""
            ])

            # Set bone positions for this frame
            for bone_name in self.SKELETON_HIERARCHY.keys():
                if bone_name == 'root':
                    continue

                bone_info = self.SKELETON_HIERARCHY[bone_name]

                if 'landmark' in bone_info:
                    landmark_id = bone_info['landmark']
                    landmark_data = frame_data[frame_data['landmark_id'] == landmark_id]

                    if not landmark_data.empty:
                        x = landmark_data['x'].iloc[0]
                        y = landmark_data['y'].iloc[0]
                        z = landmark_data['z'].iloc[0] if 'z' in landmark_data else 0

                        script_lines.extend([
                            f"bone = pose_bones['{bone_name}']",
                            f"bone.location = ({x - 0.5}, {z}, {0.5 - y})",
                            f"bone.keyframe_insert('location')",
                            ""
                        ])

        script_lines.extend([
            "",
            "# Update scene",
            "bpy.context.view_layer.update()",
            "print('Animation created successfully!')"
        ])

        # Save script
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)

        with open(output_file, 'w') as f:
            f.write('\n'.join(script_lines))

        print(f"âœ“ Blender Python script saved to {output_file}")
        return str(output_file)

    def export_to_bvh(self,
                     pose_data: pd.DataFrame,
                     output_path: str,
                     reference_height: float = 180.0) -> str:
        """
        Export pose data to BVH (Biovision Hierarchy) format.

        Args:
            pose_data: DataFrame with pose landmarks
            output_path: Path for output .bvh file
            reference_height: Reference height in cm

        Returns:
            Path to generated BVH file
        """
        bvh_lines = []

        # BVH Header
        bvh_lines.extend([
            "HIERARCHY",
            "ROOT Hips",
            "{",
            "\tOFFSET 0.00 0.00 0.00",
            "\tCHANNELS 6 Xposition Yposition Zposition Zrotation Xrotation Yrotation"
        ])

        # Add skeleton hierarchy
        self._add_bvh_joint(bvh_lines, "Spine", 1, has_end=False)
        self._add_bvh_joint(bvh_lines, "Neck", 2, has_end=False)
        self._add_bvh_joint(bvh_lines, "Head", 3, has_end=True)

        bvh_lines.append("\t}")  # Close Neck
        bvh_lines.append("\t}")  # Close Spine

        # Left arm
        self._add_bvh_joint(bvh_lines, "LeftShoulder", 1, has_end=False)
        self._add_bvh_joint(bvh_lines, "LeftArm", 2, has_end=False)
        self._add_bvh_joint(bvh_lines, "LeftForeArm", 3, has_end=False)
        self._add_bvh_joint(bvh_lines, "LeftHand", 4, has_end=True)
        bvh_lines.extend(["\t}", "\t}", "\t}"])  # Close arm chain

        # Right arm
        self._add_bvh_joint(bvh_lines, "RightShoulder", 1, has_end=False)
        self._add_bvh_joint(bvh_lines, "RightArm", 2, has_end=False)
        self._add_bvh_joint(bvh_lines, "RightForeArm", 3, has_end=False)
        self._add_bvh_joint(bvh_lines, "RightHand", 4, has_end=True)
        bvh_lines.extend(["\t}", "\t}", "\t}"])  # Close arm chain

        # Left leg
        self._add_bvh_joint(bvh_lines, "LeftUpLeg", 1, has_end=False)
        self._add_bvh_joint(bvh_lines, "LeftLeg", 2, has_end=False)
        self._add_bvh_joint(bvh_lines, "LeftFoot", 3, has_end=True)
        bvh_lines.extend(["\t}", "\t}"])  # Close leg chain

        # Right leg
        self._add_bvh_joint(bvh_lines, "RightUpLeg", 1, has_end=False)
        self._add_bvh_joint(bvh_lines, "RightLeg", 2, has_end=False)
        self._add_bvh_joint(bvh_lines, "RightFoot", 3, has_end=True)
        bvh_lines.extend(["\t}", "\t}"])  # Close leg chain

        bvh_lines.append("}")  # Close ROOT

        # Motion data
        num_frames = pose_data['frame_id'].nunique()
        frame_time = 1.0 / self.fps

        bvh_lines.extend([
            "MOTION",
            f"Frames: {num_frames}",
            f"Frame Time: {frame_time:.6f}"
        ])

        # Add motion data for each frame
        for frame_id in sorted(pose_data['frame_id'].unique()):
            frame_data = pose_data[pose_data['frame_id'] == frame_id]
            motion_values = self._calculate_bvh_motion(frame_data, reference_height)
            bvh_lines.append(" ".join([f"{v:.6f}" for v in motion_values]))

        # Save BVH file
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)

        with open(output_file, 'w') as f:
            f.write('\n'.join(bvh_lines))

        print(f"âœ“ BVH file saved to {output_file}")
        return str(output_file)

    def export_to_fbx_ascii(self,
                           pose_data: pd.DataFrame,
                           output_path: str) -> str:
        """
        Export pose data to FBX ASCII format.

        Args:
            pose_data: DataFrame with pose landmarks
            output_path: Path for output .fbx file

        Returns:
            Path to generated FBX file
        """
        # FBX ASCII format header
        fbx_content = [
            "; FBX 7.4.0 project file",
            "; Generated by BodyScript Creative Platform",
            "",
            "FBXHeaderExtension: {",
            "\tFBXHeaderVersion: 1003",
            "\tFBXVersion: 7400",
            "\tCreator: \"BodyScript\"",
            "}",
            "",
            "GlobalSettings: {",
            "\tVersion: 1000",
            "\tProperties70: {",
            f'\t\tP: "UpAxis", "int", "Integer", "",1',
            f'\t\tP: "UpAxisSign", "int", "Integer", "",1',
            f'\t\tP: "FrontAxis", "int", "Integer", "",2',
            f'\t\tP: "FrontAxisSign", "int", "Integer", "",1',
            f'\t\tP: "CoordAxis", "int", "Integer", "",0',
            f'\t\tP: "CoordAxisSign", "int", "Integer", "",1',
            f'\t\tP: "FrameRate", "double", "Number", "",{self.fps}',
            "\t}",
            "}",
            ""
        ]

        # Add definitions
        fbx_content.extend([
            "Definitions: {",
            "\tVersion: 100",
            "\tObjectType: \"Model\" {",
            "\t}",
            "\tObjectType: \"NodeAttribute\" {",
            "\t}",
            "\tObjectType: \"Deformer\" {",
            "\t}",
            "\tObjectType: \"AnimationCurveNode\" {",
            "\t}",
            "\tObjectType: \"AnimationCurve\" {",
            "\t}",
            "}",
            ""
        ])

        # Add objects (skeleton)
        fbx_content.append("Objects: {")

        # Create skeleton nodes
        node_id = 1000000
        for bone_name in self.SKELETON_HIERARCHY.keys():
            fbx_content.extend([
                f"\tModel: {node_id}, \"Model::{bone_name}\", \"LimbNode\" {{",
                "\t\tVersion: 232",
                "\t\tProperties70: {",
                f'\t\t\tP: "PreRotation", "Vector3D", "Vector", "",0,0,0',
                f'\t\t\tP: "PostRotation", "Vector3D", "Vector", "",0,0,0',
                f'\t\t\tP: "RotationActive", "bool", "", "",1',
                f'\t\t\tP: "ScalingMax", "Vector3D", "Vector", "",1,1,1',
                f'\t\t\tP: "DefaultAttributeIndex", "int", "Integer", "",0',
                "\t\t}",
                "\t}",
                ""
            ])
            node_id += 1

        # Add animation curves
        fbx_content.append("\t; Animation curves would go here")
        fbx_content.append("}")

        # Add connections
        fbx_content.extend([
            "",
            "Connections: {",
            "\t; Connect skeleton hierarchy"
        ])

        # Connect bones based on hierarchy
        node_id = 1000000
        for bone_name, bone_info in self.SKELETON_HIERARCHY.items():
            if bone_info['parent']:
                parent_id = 1000000 + list(self.SKELETON_HIERARCHY.keys()).index(bone_info['parent'])
                fbx_content.append(f"\tC: \"OO\",{node_id},{parent_id}")
            node_id += 1

        fbx_content.append("}")

        # Save FBX file
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)

        with open(output_file, 'w') as f:
            f.write('\n'.join(fbx_content))

        print(f"âœ“ FBX ASCII file saved to {output_file}")
        return str(output_file)

    def export_to_json_animation(self,
                                pose_data: pd.DataFrame,
                                output_path: str) -> str:
        """
        Export pose data as JSON animation format.

        Args:
            pose_data: DataFrame with pose landmarks
            output_path: Path for output .json file

        Returns:
            Path to generated JSON file
        """
        animation = {
            'metadata': {
                'format': 'BodyScript Animation 1.0',
                'fps': self.fps,
                'total_frames': pose_data['frame_id'].nunique(),
                'duration': pose_data['frame_id'].nunique() / self.fps,
                'landmark_count': 33
            },
            'skeleton': {},
            'animation': []
        }

        # Add skeleton structure
        for bone_name, bone_info in self.SKELETON_HIERARCHY.items():
            animation['skeleton'][bone_name] = {
                'parent': bone_info['parent'],
                'landmark': bone_info.get('landmark', None),
                'landmarks': bone_info.get('landmarks', None)
            }

        # Add animation frames
        for frame_id in sorted(pose_data['frame_id'].unique()):
            frame_data = pose_data[pose_data['frame_id'] == frame_id]

            frame_poses = {
                'frame': int(frame_id),
                'time': frame_id / self.fps,
                'poses': {}
            }

            # Add landmark positions
            for _, landmark in frame_data.iterrows():
                landmark_id = int(landmark['landmark_id'])
                frame_poses['poses'][f'landmark_{landmark_id}'] = {
                    'x': float(landmark['x']),
                    'y': float(landmark['y']),
                    'z': float(landmark.get('z', 0)),
                    'visibility': float(landmark.get('visibility', 1.0))
                }

            animation['animation'].append(frame_poses)

        # Save JSON file
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)

        with open(output_file, 'w') as f:
            json.dump(animation, f, indent=2)

        print(f"âœ“ JSON animation saved to {output_file}")
        return str(output_file)

    def export_to_csv_3d(self,
                        pose_data: pd.DataFrame,
                        output_path: str) -> str:
        """
        Export pose data as CSV with 3D coordinates.

        Args:
            pose_data: DataFrame with pose landmarks
            output_path: Path for output .csv file

        Returns:
            Path to generated CSV file
        """
        # Ensure we have 3D coordinates
        if 'z' not in pose_data.columns:
            pose_data['z'] = 0

        # Add bone connections
        pose_data['bone'] = pose_data['landmark_id'].map(self._get_bone_name)

        # Add normalized coordinates (0-1 range)
        pose_data['x_norm'] = pose_data['x']
        pose_data['y_norm'] = pose_data['y']
        pose_data['z_norm'] = (pose_data['z'] - pose_data['z'].min()) / (pose_data['z'].max() - pose_data['z'].min() + 1e-6)

        # Select columns for export
        export_columns = [
            'frame_id', 'timestamp', 'landmark_id', 'bone',
            'x', 'y', 'z',
            'x_norm', 'y_norm', 'z_norm',
            'visibility'
        ]

        # Filter available columns
        export_columns = [col for col in export_columns if col in pose_data.columns]

        # Save CSV
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)

        pose_data[export_columns].to_csv(output_file, index=False)

        print(f"âœ“ 3D CSV saved to {output_file}")
        return str(output_file)

    def _build_skeleton(self) -> Dict[str, Bone]:
        """Build skeleton structure from hierarchy."""
        skeleton = {}

        for bone_name, bone_info in self.SKELETON_HIERARCHY.items():
            skeleton[bone_name] = Bone(
                name=bone_name,
                parent=bone_info['parent'],
                position=(0, 0, 0),
                rotation=(0, 0, 0),
                children=[]
            )

        # Set children
        for bone_name, bone in skeleton.items():
            if bone.parent and bone.parent in skeleton:
                skeleton[bone.parent].children.append(bone_name)

        return skeleton

    def _calculate_bone_positions(self,
                                 pose_data: pd.DataFrame) -> Dict[str, np.ndarray]:
        """Calculate average bone positions from pose data."""
        positions = {}

        first_frame = pose_data[pose_data['frame_id'] == pose_data['frame_id'].min()]

        for bone_name, bone_info in self.SKELETON_HIERARCHY.items():
            if 'landmark' in bone_info:
                landmark_data = first_frame[first_frame['landmark_id'] == bone_info['landmark']]
                if not landmark_data.empty:
                    positions[bone_name] = np.array([
                        landmark_data['x'].iloc[0],
                        landmark_data['y'].iloc[0],
                        landmark_data.get('z', 0).iloc[0]
                    ])
            elif 'landmarks' in bone_info:
                landmarks_data = first_frame[first_frame['landmark_id'].isin(bone_info['landmarks'])]
                if not landmarks_data.empty:
                    positions[bone_name] = np.array([
                        landmarks_data['x'].mean(),
                        landmarks_data['y'].mean(),
                        landmarks_data.get('z', 0).mean()
                    ])

        return positions

    def _add_bvh_joint(self,
                      lines: List[str],
                      name: str,
                      level: int,
                      has_end: bool = False):
        """Add a joint to BVH hierarchy."""
        indent = "\t" * level

        if has_end:
            lines.extend([
                f"{indent}End Site",
                f"{indent}{{",
                f"{indent}\tOFFSET 0.00 5.00 0.00",
                f"{indent}}}"
            ])
        else:
            lines.extend([
                f"{indent}JOINT {name}",
                f"{indent}{{",
                f"{indent}\tOFFSET 0.00 5.00 0.00",
                f"{indent}\tCHANNELS 3 Zrotation Xrotation Yrotation"
            ])

    def _calculate_bvh_motion(self,
                            frame_data: pd.DataFrame,
                            reference_height: float) -> List[float]:
        """Calculate BVH motion values for a frame."""
        # This is simplified - full implementation would calculate actual rotations
        motion = []

        # Root position (6 values: position + rotation)
        hip_landmarks = frame_data[frame_data['landmark_id'].isin([23, 24])]
        if not hip_landmarks.empty:
            hip_center_x = hip_landmarks['x'].mean() * reference_height
            hip_center_y = hip_landmarks['y'].mean() * reference_height
            hip_center_z = hip_landmarks.get('z', 0).mean() * reference_height
            motion.extend([hip_center_x, hip_center_y, hip_center_z, 0, 0, 0])
        else:
            motion.extend([0, 0, 0, 0, 0, 0])

        # Add rotation values for each joint (simplified to 0 for now)
        # In a full implementation, these would be calculated from landmark positions
        num_joints = 15  # Approximate number of joints in hierarchy
        for _ in range(num_joints):
            motion.extend([0, 0, 0])  # ZXY rotation

        return motion

    def _get_bone_name(self, landmark_id: int) -> str:
        """Get bone name for a landmark ID."""
        for bone_name, bone_info in self.SKELETON_HIERARCHY.items():
            if 'landmark' in bone_info and bone_info['landmark'] == landmark_id:
                return bone_name
            elif 'landmarks' in bone_info and landmark_id in bone_info['landmarks']:
                return bone_name
        return f"landmark_{landmark_id}"


def test_3d_export():
    """Test the 3D export module."""
    print("\n=== Testing 3D Export Module ===\n")

    # Create sample pose data
    np.random.seed(42)
    n_frames = 30
    data = []

    for frame_id in range(n_frames):
        for landmark_id in range(33):
            # Create walking motion
            phase = frame_id * 0.2
            x = 0.5 + 0.1 * np.sin(phase + landmark_id * 0.1)
            y = 0.5 + 0.1 * np.cos(phase + landmark_id * 0.1)
            z = 0.1 * np.sin(phase * 2)

            data.append({
                'frame_id': frame_id,
                'timestamp': frame_id / 30.0,
                'landmark_id': landmark_id,
                'x': x,
                'y': y,
                'z': z,
                'visibility': 0.95
            })

    pose_df = pd.DataFrame(data)

    # Initialize exporter
    exporter = Export3D(fps=30)

    # Test different export formats
    print("Testing export formats:")

    # Export to Blender Python
    blender_path = exporter.export_to_blender_python(
        pose_df, 'test_export_blender.py'
    )

    # Export to BVH
    bvh_path = exporter.export_to_bvh(
        pose_df, 'test_export.bvh'
    )

    # Export to FBX ASCII
    fbx_path = exporter.export_to_fbx_ascii(
        pose_df, 'test_export.fbx'
    )

    # Export to JSON
    json_path = exporter.export_to_json_animation(
        pose_df, 'test_export_animation.json'
    )

    # Export to CSV
    csv_path = exporter.export_to_csv_3d(
        pose_df, 'test_export_3d.csv'
    )

    print("\nâœ“ All export formats generated successfully")


if __name__ == "__main__":
    test_3d_export()